1. 객체 지향에 대해 논하시오.
	하나의 프로그램을 만들 때 세부적인 작동을 담당하는 코드들을 따로 관리 할 수 있도록 코드의 목적에 따라서 분류를 하여, 분류 	된 코드들을 따로 제작하고 완성 전에 조립하는 방식.

2. 지뢰 찾기를 만드시오
 - 알고있는 내용 모두 사용해서.
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#include<stdlib.h>
#include<time.h>
#define LAND_MAIN 10	
#define SAFE 11

void find_land_main(int map[][10], int x, int y)
{
	int count = 0;
	int ro;
	if (x >= 0 && x<10 && y >= 0 && y<5) //8방탐색
	{
		for (int Y = y - 1; Y <= y + 1; Y++)
		{
			for (int X = x - 1; X <= x + 1; X++)
			{
				if (X >= 0 && X < 5 && X >= 0 && X < 10)
				{
					if (map[Y][X] == LAND_MAIN)
						count++;
				}
			}
		}

		if (count > 0)
		{
			map[y][x] = count;
			return;
		}
		else
		{
			map[y][x] = SAFE;
			for (int Y = y - 1; Y <= y + 1; Y++) //그리기
			{
				for (int X = x - 1; X <= x + 1; X++)
				{
					if (X >= 0 && X < 5 && X >= 0 && X < 10)
					{
						if (map[Y][X] < 1)
						{
							map[Y][X] = SAFE;
						}
					}
				}
			}

			if (x > 1 && x < 8 && y > 1 && y < 3) //8방의 8방탐색
			{

				find_land_main(map, x - 1, y);
				find_land_main(map, x, y - 1);
				find_land_main(map, x + 1, y);
				find_land_main(map, x, y + 1);
				find_land_main(map, x - 1, y - 1);
				find_land_main(map, x + 1, y + 1);
				find_land_main(map, x - 1, y + 1);
				find_land_main(map, x + 1, y - 1);
			}
		}
	}
}

void main()
{
	int map[5][10] = { 0 };
	int x, y,wincount = 0;
	srand(time(NULL));
	for (int i = 0; i < 5; i++)
	{
		x = (rand() % 10);
		y = (rand() % 5);
		map[y][x] = LAND_MAIN;
	}

	while (1)
	{
		system("cls");
		for (int Y = 0; Y < 5; Y++)
		{
			for (int X = 0; X < 10; X++)
			{
				if (map[Y][X] == SAFE)
					printf("□");
				else if (map[Y][X] == 0 /*|| map[Y][X] == LAND_MAIN*/)
					printf("■");
				else if(map[Y][X] == LAND_MAIN)
					printf("※");
				else if (map[Y][X] > 0 && map[Y][X] < SAFE)
					printf(" %d", map[Y][X]);
			}
			printf("\n");
		}
		while (1)
		{
			printf("좌표를 입력하세요 \n");
			printf("X :");
			scanf("%d", &x);
			printf("Y :");
			scanf("%d", &y);
			if (x < 10 && x >= 0 && y<5 && y >= 0)
			{
				break;
			}
			printf("다시입력 \n");
		}
		if (map[y][x] != LAND_MAIN)
		{
			find_land_main(map, x, y);
		}
		else if (map[y][x] == LAND_MAIN)
		{
			printf("\n 앗! 지뢰입니다. -GAME OVER- \n");
			system("pause");
			return;
		}
		//승리체크
		for (int Y = 0; Y < 5; Y++)
		{
			for (int X = 0; X < 10; X++)
			{
				if (map[y][X] == 0)
				{
					wincount++;
				}
			}
		}
		if (wincount > 0)
			wincount = 0;
		else
			printf("\n 지뢰찾기 승리! - Win - \n");
	}
}
3. 미로찾기를 자신이 컨트롤하는 것이 아닌 미로탐색을 
시작점부터 스스로해서 빠져나가는 어플리케이션을 만드시오.
 - 알고있는 내용 모두 사용해서.
#define 1 WALL
#define 3 ME
#define 5 CLEAR

	int map[15,10] =
	{1,1,3,1,1,1,1,1,1,1,1,1,1,1,1},
	{1,1,2,2,2,0,1,0,1,0,0,0,0,0,1},
	{1,1,1,1,2,0,1,0,0,0,1,1,1,0,1},
	{1,0,1,0,2,2,0,1,2,2,2,0,1,0,1},
	{1,0,0,0,1,2,0,1,2,1,2,1,1,1,1},
	{1,1,1,1,1,2,2,2,2,1,2,2,1,0,1},
	{1,0,0,0,1,0,0,0,1,1,1,2,0,0,1},
	{1,1,1,0,0,0,1,1,1,0,0,2,1,1,1},
	{1,0,0,0,1,0,0,0,1,0,1,2,2,0,1},
	{1,1,1,1,1,1,1,1,1,1,1,1,5,1,1}
	int x,y;
	while(1)
	{
		Sleep(1000);
		for(int X=0; X<15; X++)
		{
			for(int Y=0; Y<15; Y++)
			{	
				if(map[X,Y] == 1)
					printf("▦");
				if(map[X,Y] == 3)
					printf("웃");
				else
					printf("  ");
			}
			printf("\n");
		}
		for(int X=0; X<15; X++)
		{
			for(int Y=0; Y<15; Y++)
			{	
				if(map[X,Y] == 3)
				{
					map[X,Y]=0
					if(map[X-1,Y]==2)
						map[X-1,Y] = 3;
					else if(map[X+1,Y] ==2)
						map[X+1,Y] = 3;
					else if(map[X,Y-1] ==2)
						map[X,Y-1] = 3;
					else if(map[X,Y+1] ==2)
						map[X,Y+1] = 3;
					else if(map[X-1,Y]==5 || map[X+1,Y] ==5 || map[X,Y-1] ==5 || map[X,Y+1] ==5)
					{
						printf("클리어!");
						system("pause");
						return;
					}					
				}
			}
		}
	}



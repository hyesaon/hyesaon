1. 객체 지향에 대해 논하시오.
	하나의 프로그램을 만들 때 세부적인 작동을 담당하는 코드들을 따로 관리 할 수 있도록 코드의 목적에 따라서 분류를 하여, 분류 	된 코드들을 따로 제작하고 완성 전에 조립하는 방식.

2. 지뢰 찾기를 만드시오
 - 알고있는 내용 모두 사용해서.
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#include<stdlib.h>
#include<time.h>
#define LAND_MAIN 10	
#define SAFE 11

void find_land_main(int map[][10],int x,int y)
{
	if (x < 0 || x>10 || y < 0 || y>10)
	{
		return;
	}

	int count = 0;
	for (int i = x - 1; i <= x + 1; i++)
	{
		for (int j = y - 1; j <= y + 1; j++)
		{
			if (i >= 0 && i < 5 && j >= 0 && j < 10)
			{
				if (map[i][j] != LAND_MAIN)
				{
					map[i][j] = SAFE;
				}
				else if (map[i][j] == LAND_MAIN)
					count++;
			}
		}
	}

	if (count > 0)
		map[x][y] = count;
	else
	{
		find_land_main(map, x-1, y);
		find_land_main(map, x, y-1);
		find_land_main(map, x+1, y);
		find_land_main(map, x, y+1);
		find_land_main(map, x-1, y-1);
		find_land_main(map, x+1, y+1);
		find_land_main(map, x-1, y+1);
		find_land_main(map, x+1, y-1);
	}
}

void main()
{
	int map[5][10] = { 0 };
	int x, y;
	srand(time(NULL));
	for (int i = 0; i < 5; i++)
	{
		x = (rand() % 5);
		y = (rand() % 10);
		map[x][y] = LAND_MAIN;
	}

	for (int X = 0; X < 5; X++)
	{
		for (int Y = 0; Y < 10; Y++)
		{
			printf("[%d]", map[X][Y]);
		}
		printf("\n");
	}
	system("pause");
	while (1)
	{
		system("cls");
		for (int X = 0; X < 5; X++)
		{
			for (int Y = 0; Y < 10; Y++)
			{
				if (map[X][Y] == SAFE)
					printf(" □");
				else if (map[X][Y] == 0 || map[X][Y] == LAND_MAIN)
					printf(" ■");
				else if (map[X][Y] > 0 && map[X][Y] < SAFE)
					printf("[%d]", map[X][Y]);
			}
			printf("\n");
		}
		printf("좌표를 입력하세요 \n");
		printf("X :");
		scanf("%d", &x);
		printf("Y :");
		scanf("%d",&y);
		if (map[x][y] != LAND_MAIN)
		{
			find_land_main(map, x, y);
		}
		else if (map[x][y] == LAND_MAIN)
		{
			printf("\n 앗! 지뢰입니다. -GAME OVER- \n");
			system("pause");
			return;
		}

		for (int X = 0; X < 5; X++)
		{
			for (int Y = 0; Y < 10; Y++)
			{
				if (map[X][Y] == 0)
				{
					//승리체크?
				}
			}
		}

	}
}
3. 미로찾기를 자신이 컨트롤하는 것이 아닌 미로탐색을 
시작점부터 스스로해서 빠져나가는 어플리케이션을 만드시오.
 - 알고있는 내용 모두 사용해서.
#define 1 WALL
#define 3 ME
#define 5 CLEAR

	int map[15,10] =
	{1,1,3,1,1,1,1,1,1,1,1,1,1,1,1},
	{1,1,2,2,2,0,1,0,1,0,0,0,0,0,1},
	{1,1,1,1,2,0,1,0,0,0,1,1,1,0,1},
	{1,0,1,0,2,2,0,1,2,2,2,0,1,0,1},
	{1,0,0,0,1,2,0,1,2,1,2,1,1,1,1},
	{1,1,1,1,1,2,2,2,2,1,2,2,1,0,1},
	{1,0,0,0,1,0,0,0,1,1,1,2,0,0,1},
	{1,1,1,0,0,0,1,1,1,0,0,2,1,1,1},
	{1,0,0,0,1,0,0,0,1,0,1,2,2,0,1},
	{1,1,1,1,1,1,1,1,1,1,1,1,5,1,1}
	int x,y;
	while(1)
	{
		Sleep(1000);
		for(int X=0; X<15; X++)
		{
			for(int Y=0; Y<15; Y++)
			{	
				if(map[X,Y] == 1)
					printf("▦");
				if(map[X,Y] == 3)
					printf("웃");
				else
					printf("  ");
			}
			printf("\n");
		}
		for(int X=0; X<15; X++)
		{
			for(int Y=0; Y<15; Y++)
			{	
				if(map[X,Y] == 3)
				{
					map[X,Y]=0
					if(map[X-1,Y]==2)
						map[X-1,Y] = 3;
					else if(map[X+1,Y] ==2)
						map[X+1,Y] = 3;
					else if(map[X,Y-1] ==2)
						map[X,Y-1] = 3;
					else if(map[X,Y+1] ==2)
						map[X,Y+1] = 3;
					else if(map[X-1,Y]==5 || map[X+1,Y] ==5 || map[X,Y-1] ==5 || map[X,Y+1] ==5)
					{
						printf("클리어!");
						system("pause");
						return;
					}					
				}
			}
		}
	}



1. 객체 지향에 대해 논하시오.
	하나의 프로그램을 만들 때 세부적인 작동을 담당하는 코드들을 따로 관리 할 수 있도록 코드의 목적에 따라서 분류를 하여, 분류 	된 코드들을 따로 제작하고 완성 전에 조립하는 방식.

2. 지뢰 찾기를 만드시오
 - 알고있는 내용 모두 사용해서.
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#include<stdlib.h>
#include<time.h>
#define LAND_MAIN 10	
#define SAFE 11

int find_land_main(int map[][10], int x, int y)
{
	int count = 0;
	if (y < 0 || y > 4 || x < 0 || x > 9)
		return 0;

	for (int Y = y - 1; Y <= y + 1; Y++)
	{
		for (int X = x - 1; X <= x + 1; X++)
		{
			if (Y >= 0 && Y < 5 && X >= 0 && X < 10)
			{
				if (map[Y][X] == LAND_MAIN)
					count++;
			}
		}
	}
	return count;
}

void up_date(int map[][10], int x, int y)
{
	int land_main = 0;
	if (x >= 0 && x < 10 && y >= 0 && y < 5)
	{
		land_main = find_land_main(map, x, y);
		if (land_main == 0)
		{
			map[y][x] = SAFE;
			//up_date(map, x - 1, y);
			//up_date(map, x + 1, y);
			//up_date(map, x, y - 1);
			//up_date(map, x, y + 1);
			//up_date(map, x - 1, y - 1);
			//up_date(map, x + 1, y + 1);
			//up_date(map, x + 1, y - 1);
			//up_date(map, x - 1, y + 1);
		}
		else
		{
			map[y][x] = land_main;
		}
	}
}

void main()
{
	int map[5][10] = { 0 };
	int x, y,wincount = 0;
	srand(time(NULL));
	for (int i = 0; i < 5; i++)
	{
		x = (rand() % 10);
		y = (rand() % 5);
		map[y][x] = LAND_MAIN;
	}

	while (1)
	{
		system("cls");
		for (int Y = 0; Y < 5; Y++)
		{
			for (int X = 0; X < 10; X++)
			{
				if (map[Y][X] == SAFE)
					printf("□");
				else if (map[Y][X] == 0 /*|| map[Y][X] == LAND_MAIN*/)
					printf("■");
				else if(map[Y][X] == LAND_MAIN)
					printf("※");
				else if (map[Y][X] > 0 && map[Y][X] < SAFE)
					printf(" %d", map[Y][X]);
			}
			printf("\n");
		}
		while (1)
		{
			printf("좌표를 입력하세요 \n");
			printf("X :");
			scanf("%d", &x);
			printf("Y :");
			scanf("%d", &y);
			if (x < 10 && x >= 0 && y<5 && y >= 0)
			{
				break;
			}
			printf("다시입력 \n");
		}
		if (map[y][x] != LAND_MAIN)
		{
			up_date(map, x, y);
		}
		else if (map[y][x] == LAND_MAIN)
		{
			printf("\n 앗! 지뢰입니다. -GAME OVER- \n");
			system("pause");
			return;
		}
		for (int Y = 0; Y < 5; Y++)
		{
			for (int X = 0; X < 10; X++)
			{
				if (map[y][X] == 0)
				{
					wincount++;
				}
			}
		}
		if (wincount > 0)
			wincount = 0;
		else
			printf("\n 지뢰찾기 승리! - Win - \n");
	}
}
3. 미로찾기를 자신이 컨트롤하는 것이 아닌 미로탐색을 
시작점부터 스스로해서 빠져나가는 어플리케이션을 만드시오.
 - 알고있는 내용 모두 사용해서.
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#include<stdlib.h>
#include<Windows.h>
#include<stack>

#define WALL 1
#define ME 3
#define WAY 4
#define NO_WAY 5
#define CLEAR 2

void map_draw(int map[][15])
{
	for (int Y = 0; Y < 10; Y++)
	{
		for (int X = 0; X < 15; X++)
		{
			if (map[Y][X] == 1)
				printf("▦");
			else if (map[Y][X] == 3)
			{
				printf("◎");
			}
			else
				printf("  ");
		}
		printf("\n");
	}
}

bool move(int map[][15],int x, int y, 
	std::stack<int>* character_X, std::stack<int>* character_Y)
{
	if (x > 0 && x < 15 && y>0 && y < 10)
	{
		if (map[y][x + 1] == 5 || map[y][x - 1] == 5
			|| map[y + 1][x] == 5 || map[y - 1][x] == 5
			|| map[y + 1][x + 1] == 5 || map[y - 1][x - 1] == 5
			|| map[y - 1][x + 1] == 5 || map[y + 1][x - 1] == 5)
		{
			return true;
		}
		else if (map[y][x] != WALL)
		{
			(*character_X).push(x);
			(*character_Y).push(y);
			map[y][x] = 0;
			x += 1;
			if (!move(map, x, y, character_X, character_Y)) //작성중
			{
				x -= 1;
				y += 1;
				if (!move(map, x, y, character_X, character_Y))
				{
					y += 1;
					if (!move(map, x, y + 1, character_X, character_Y))
					{
						move(map, x, y - 1, character_X, character_Y);
					}
				}
			}
			return false;
		}
	}
}
void main()
{
	int map[10][15] = {
	{ 1,1,3,1,1,1,1,1,1,1,1,1,1,1,1 },
	{ 1,1,0,0,0,0,1,0,1,0,0,0,0,0,1 },
	{ 1,1,1,1,0,0,1,0,0,0,1,1,1,0,1 },
	{ 1,0,1,0,0,0,0,1,0,0,0,0,1,0,1 },
	{ 1,0,0,0,1,0,0,1,0,1,0,1,1,1,1 },
	{ 1,1,1,1,1,0,0,0,0,1,0,0,1,0,1 },
	{ 1,0,0,0,1,0,0,0,1,1,1,0,0,0,1 },
	{ 1,1,1,0,0,0,1,1,1,0,0,0,1,1,1 },
	{ 1,0,0,0,1,0,0,0,1,0,1,0,0,0,1 },
	{ 1,1,1,1,1,1,1,1,1,1,1,1,2,1,1 } 
	};
	int x = 2, y = 0;
	std::stack<int> character_X;
	std::stack<int> character_Y;
	while (1)
	{
		Sleep(500);
		system("cls");
		map_draw(map);
		//간 길에 길없음혹은 본인이 있을 경우 > 현재 좌표를 반환하고 flase > 아니면 트루
		//만약 false인데 x12 y9 이면 출구임
		//상하좌우 모두 if > else if로. 나머지 else는 상하좌우 모두 가본길이거나 길이아닐때.
		//그때는 현재 좌표에 길없음을 놓고. 현재 좌표에 = 스텍좌표를 넣고 스텍pop. 갱신된 현재좌표에 자기자신을놓음 		

		if (move(map, x, y, &character_X, &character_Y) == true)
		{
			printf("\n 탈출!\n"); 
			return;
		}
	}
}


